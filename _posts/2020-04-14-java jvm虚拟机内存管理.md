---
title: jvm虚拟机内存管理
description: jvm虚拟机管理
tags: jvm
---

 Flink Application
-
一、 jvm内存部分
-
1. jvm组成
    - 程序计数器、虚拟机栈、本地方法栈（线程私有）
    - 方法区、堆（线程共享）

2. 运行时内存
    - 新生代
        - eden 伊甸园
            - 新创建的对象在这里产生
        - servivorFrom
            - eden经过回收，对象进入本区
        - servivorTo
            - servivorFrom 和 servivorTo 之间来回转移
        - 内存比例：eden：servivorFrom：servivorTo=8:1:1

    - 老年代
        - 新生代：老年代=1:2
        - 新生代经过多次回收后仍然你存活进入老年代
    
    - 永久代/元空间
        - 存放类信息、静态变量、常量等编译信息
        - 数据回收和老年代绑定，两个触发同一个gc
    
3. 垃圾回收与算法
    - 如何确定垃圾
        - 引用计数
        - 可达性分析
        - 引用计数无法剔除循环引用、可达性分析解决了这个问题，只要引用无法达到栈中，堆中的互相引用无效
    - 算法
        - 复制
        - 标记清除:会产生大量内存碎片
        - 标记整理
        - 分代回收
            - 新生代
                - 复制算法（在servivorFrom 和servivorTo两个内存区之间来回复制，失效的数据清除）
                - 每次回收对象年龄+1，达到阈值（一般15）就会转移到老年代 
            - 老年代
                - 标记清除
                - 标记整理：一般使用标记整理
        - 分区回收算法
            - 内存分为连续不同的很多个小区，每个小区单独使用，按照小区进行回收

4. Java的四种引用
    - 强引用：不会被回收
    - 软引用：内存不够的时候被回收
    - 弱引用：被回收
    - 虚引用：不能单独使用
    
5. 垃圾收集器
    - 新生代
        - serial 单线程  ：复制算法
        - parNew 多线程+serial ：多线程复制算法，停顿时间短
        - parallel scavenge 多线程复制算法：gc时间短
    - 老年代
        - serial old 单线程 ：单线程标记整理
        - CMS 多线程 ：停顿时间短：多线程标记清理
            - 出示标记
            - 并发标记
            - 重新标记
            - 并发清理
        - parallel old 多线程：多线程标记复制，gc时间短
        
6. jvm类加载机制
    - 加载流程
        - 加载：加载代码
        - link：连接
            - 验证：检查是否有错误
            - 准备：分配内存空间         
            - 解析：常量池中符号引用改为直接引用
        - 初始化
            - 类构造器：为静态变量赋值

    - 类加载器
        - jvm提供三种加载器
            - 启动类加载器
            - 扩展类加载器
            - 引用程序加载器
        - 双亲委派
            - 子类收到加载请求，首先不会加载，会发送到父类，父类不能加载，再委派给子类加载
            - 每次加载都会请求到 启动类加载器，最小化加载

7. jvm调优
    - 根据业务，计算每秒产生的内存大小，合理分配堆栈大小，使垃圾在新生代删除，尽量少的转移到老年代
    - 熟悉数据结构，优化代码，每次产生最小的内存 
    
    
    
     